## 문제
보물이 n개 있다. 1~m번까지 번호가 있고 탐험가는 m명이다. 
총 n라운드를 거치며 남은 자원이 가장 많은 탐험가가 보물을 찾게 된다.
 남은 자원이 같은 탐험가가 여러명일 경우, 번호가 더 작은 탐험가가 보물을 차지하게 된다.

입출력 예 1.
n = 4
resources = [85, 32, 65, 19]
result = [66, 33, 32, 20]

예 2.
n=6
resources = [3,7,1]
result = [4,3,2,1,1,-1]


## 문제풀이과정
1. 탐험가들의 자원을 기록한 배열을 초기화합니다.
2. n라운드 동안, 남은 자원이 가장 많은 탐험가를 선택하고, 그 탐험가가 보물을 차지하도록 합니다.
3. 자원이 같은 경우, 번호가 작은 탐험가가 우선권을 갖습니다.
4. 각 라운드에서 보물을 차지한 탐험가의 번호를 기록하고, 자원을 1씩 감소시킵니다.
5. 모든 라운드가 끝난 후 결과를 반환합니다.

## 코트 설명
1. 탐험가 선택: 각 라운드마다 탐험가들 중에서 남은 자원이 가장 많은 탐험가를 찾습니다. 자원이 같을 경우, 탐험가 번호가 더 작은 탐험가가 선택됩니다.
2. 자원 감소: 보물을 차지한 탐험가는 자원이 1 감소됩니다. 모든 라운드가 끝난 후 자원을 출력값으로 반환합니다.
3. 결과 저장: 각 라운드에서 남은 자원을 기록하여 반환합니다.

## 개선방법
탐험가의 자원을 가장 많이 가진 탐험가를 매 라운드마다 선형 탐색을 통해 찾는 방법은 비효율적일 수 있습니다. 이를 개선하기 위해 최대 힙(Max-Heap)을 사용하면 효율성을 높일 수 있습니다.

heapq 모듈을 사용하여 **최대 힙(Max-Heap)**을 구현할 수 있습니다. 
하지만 heapq는 기본적으로 **최소 힙(Min-Heap)**을 제공하므로, 값을 음수로 저장하여 최대 힙처럼 사용할 수 있습니다.
최대 힙을 사용하면 탐험가의 자원을 가장 많이 가진 탐험가를 빠르게 찾을 수 있으며, 자원이 감소할 때마다 해당 값을 효율적으로 업데이트할 수 있습니다. 
각 탐험가의 자원에 변화가 있을 때마다 힙을 재구성하는 과정이 O(log m) 시간이 걸리므로, 효율성이 크게 향상됩니다.

1. 최대 힙 초기화:
탐험가들의 자원을 음수로 저장한 뒤, heapq.heapify를 사용하여 최대 힙처럼 작동하게 합니다.
2. 탐험가 선택:
매 라운드마다 heapq.heappop을 사용하여 자원이 가장 많은 탐험가를 빠르게 선택합니다.
3. 자원 감소 및 재삽입:
탐험가의 자원을 1 감소시키고, 자원이 남아 있으면 다시 힙에 삽입하여 다음 라운드를 준비합니다.
